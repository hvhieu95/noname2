{"ast":null,"code":"var _this = this;\n/* eslint-disable */\n// @ts-nocheck\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\nvar isLittleEndian = function isLittleEndian() {\n  // Get byte order mark.\n  var BOM = getBytes(2, 0);\n  // Find out the endianness.\n  if (BOM === 0x4949) {\n    littleEndian = true;\n  } else if (BOM === 0x4d4d) {\n    littleEndian = false;\n  } else {\n    throw TypeError(\"Invalid byte order value.\");\n  }\n  return littleEndian;\n};\nvar hasTowel = function hasTowel() {\n  // Check for towel.\n  if (getBytes(2, 2) !== 42) {\n    throw RangeError(\"You forgot your towel!\");\n    return false;\n  }\n  return true;\n};\nvar getFieldTagName = function getFieldTagName(fieldTag) {\n  // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n  // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n  var fieldTagNames = {\n    // TIFF Baseline\n    0x013b: \"Artist\",\n    0x0102: \"BitsPerSample\",\n    0x0109: \"CellLength\",\n    0x0108: \"CellWidth\",\n    0x0140: \"ColorMap\",\n    0x0103: \"Compression\",\n    0x8298: \"Copyright\",\n    0x0132: \"DateTime\",\n    0x0152: \"ExtraSamples\",\n    0x010a: \"FillOrder\",\n    0x0121: \"FreeByteCounts\",\n    0x0120: \"FreeOffsets\",\n    0x0123: \"GrayResponseCurve\",\n    0x0122: \"GrayResponseUnit\",\n    0x013c: \"HostComputer\",\n    0x010e: \"ImageDescription\",\n    0x0101: \"ImageLength\",\n    0x0100: \"ImageWidth\",\n    0x010f: \"Make\",\n    0x0119: \"MaxSampleValue\",\n    0x0118: \"MinSampleValue\",\n    0x0110: \"Model\",\n    0x00fe: \"NewSubfileType\",\n    0x0112: \"Orientation\",\n    0x0106: \"PhotometricInterpretation\",\n    0x011c: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0116: \"RowsPerStrip\",\n    0x0115: \"SamplesPerPixel\",\n    0x0131: \"Software\",\n    0x0117: \"StripByteCounts\",\n    0x0111: \"StripOffsets\",\n    0x00ff: \"SubfileType\",\n    0x0107: \"Threshholding\",\n    0x011a: \"XResolution\",\n    0x011b: \"YResolution\",\n    // TIFF Extended\n    0x0146: \"BadFaxLines\",\n    0x0147: \"CleanFaxData\",\n    0x0157: \"ClipPath\",\n    0x0148: \"ConsecutiveBadFaxLines\",\n    0x01b1: \"Decode\",\n    0x01b2: \"DefaultImageColor\",\n    0x010d: \"DocumentName\",\n    0x0150: \"DotRange\",\n    0x0141: \"HalftoneHints\",\n    0x015a: \"Indexed\",\n    0x015b: \"JPEGTables\",\n    0x011d: \"PageName\",\n    0x0129: \"PageNumber\",\n    0x013d: \"Predictor\",\n    0x013f: \"PrimaryChromaticities\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0153: \"SampleFormat\",\n    0x022f: \"StripRowCounts\",\n    0x014a: \"SubIFDs\",\n    0x0124: \"T4Options\",\n    0x0125: \"T6Options\",\n    0x0145: \"TileByteCounts\",\n    0x0143: \"TileLength\",\n    0x0144: \"TileOffsets\",\n    0x0142: \"TileWidth\",\n    0x012d: \"TransferFunction\",\n    0x013e: \"WhitePoint\",\n    0x0158: \"XClipPathUnits\",\n    0x011e: \"XPosition\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0213: \"YCbCrPositioning\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0159: \"YClipPathUnits\",\n    0x011f: \"YPosition\",\n    // EXIF\n    0x9202: \"ApertureValue\",\n    0xa001: \"ColorSpace\",\n    0x9004: \"DateTimeDigitized\",\n    0x9003: \"DateTimeOriginal\",\n    0x8769: \"Exif IFD\",\n    0x9000: \"ExifVersion\",\n    0x829a: \"ExposureTime\",\n    0xa300: \"FileSource\",\n    0x9209: \"Flash\",\n    0xa000: \"FlashpixVersion\",\n    0x829d: \"FNumber\",\n    0xa420: \"ImageUniqueID\",\n    0x9208: \"LightSource\",\n    0x927c: \"MakerNote\",\n    0x9201: \"ShutterSpeedValue\",\n    0x9286: \"UserComment\",\n    // IPTC\n    0x83bb: \"IPTC\",\n    // ICC\n    0x8773: \"ICC Profile\",\n    // XMP\n    0x02bc: \"XMP\",\n    // GDAL\n    0xa480: \"GDAL_METADATA\",\n    0xa481: \"GDAL_NODATA\",\n    // Photoshop\n    0x8649: \"Photoshop\"\n  };\n  var fieldTagName;\n  if (fieldTag in fieldTagNames) {\n    fieldTagName = fieldTagNames[fieldTag];\n  } else {\n    fieldTagName = \"Tag\" + fieldTag;\n  }\n  return fieldTagName;\n};\nvar getFieldTypeName = function getFieldTypeName(fieldType) {\n  var fieldTypeNames = {\n    0x0001: \"BYTE\",\n    0x0002: \"ASCII\",\n    0x0003: \"SHORT\",\n    0x0004: \"LONG\",\n    0x0005: \"RATIONAL\",\n    0x0006: \"SBYTE\",\n    0x0007: \"UNDEFINED\",\n    0x0008: \"SSHORT\",\n    0x0009: \"SLONG\",\n    0x000a: \"SRATIONAL\",\n    0x000b: \"FLOAT\",\n    0x000c: \"DOUBLE\"\n  };\n  var fieldTypeName;\n  if (fieldType in fieldTypeNames) {\n    fieldTypeName = fieldTypeNames[fieldType];\n  }\n  return fieldTypeName;\n};\nvar getFieldTypeLength = function getFieldTypeLength(fieldTypeName) {\n  var fieldTypeLength;\n  if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 1;\n  } else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 2;\n  } else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 4;\n  } else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 8;\n  }\n  return fieldTypeLength;\n};\nvar getBits = function getBits(numBits, byteOffset, bitOffset) {\n  bitOffset = bitOffset || 0;\n  var extraBytes = Math.floor(bitOffset / 8);\n  var newByteOffset = byteOffset + extraBytes;\n  var totalBits = bitOffset + numBits;\n  var shiftRight = 32 - numBits;\n  if (totalBits <= 0) {\n    throw RangeError(\"No bits requested\");\n  } else if (totalBits <= 8) {\n    var shiftLeft = 24 + bitOffset;\n    var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n  } else if (totalBits <= 16) {\n    var shiftLeft = 16 + bitOffset;\n    var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n  } else if (totalBits <= 32) {\n    var shiftLeft = bitOffset;\n    var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bits requested\");\n  }\n  var chunkInfo = {\n    bits: rawBits << shiftLeft >>> shiftRight,\n    byteOffset: newByteOffset + Math.floor(totalBits / 8),\n    bitOffset: totalBits % 8\n  };\n  return chunkInfo;\n};\nvar getBytes = function getBytes(numBytes, offset) {\n  if (numBytes <= 0) {\n    throw RangeError(\"No bytes requested\");\n  } else if (numBytes <= 1) {\n    return tiffDataView.getUint8(offset, littleEndian);\n  } else if (numBytes <= 2) {\n    return tiffDataView.getUint16(offset, littleEndian);\n  } else if (numBytes <= 3) {\n    return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n  } else if (numBytes <= 4) {\n    return tiffDataView.getUint32(offset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bytes requested\");\n  }\n};\nvar getFieldValues = function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {\n  var fieldValues = [];\n  var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n  var fieldValueSize = fieldTypeLength * typeCount;\n  if (fieldValueSize <= 4) {\n    // The value is stored at the big end of the valueOffset.\n    if (littleEndian === false) {\n      var value = valueOffset >>> (4 - fieldTypeLength) * 8;\n    } else {\n      var value = valueOffset;\n    }\n    fieldValues.push(value);\n  } else {\n    for (var i = 0; i < typeCount; i++) {\n      var indexOffset = fieldTypeLength * i;\n      if (fieldTypeLength >= 8) {\n        if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n          // Numerator\n          fieldValues.push(getBytes(4, valueOffset + indexOffset));\n          // Denominator\n          fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));\n          //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n          //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n        } else {\n          throw TypeError(\"Can't handle this field type or size\");\n        }\n      } else {\n        fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n      }\n    }\n  }\n  if (fieldTypeName === \"ASCII\") {\n    fieldValues.forEach(function (e, i, a) {\n      a[i] = String.fromCharCode(e);\n    });\n  }\n  return fieldValues;\n};\nvar clampColorSample = function clampColorSample(colorSample, bitsPerSample) {\n  var multiplier = Math.pow(2, 8 - bitsPerSample);\n  return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\nvar makeRGBAFillValue = function makeRGBAFillValue(r, g, b, a) {\n  if (typeof a === \"undefined\") {\n    a = 1.0;\n  }\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\nvar parseFileDirectory = function parseFileDirectory(byteOffset) {\n  var numDirEntries = getBytes(2, byteOffset);\n  var tiffFields = [];\n  for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n    var fieldTag = getBytes(2, i);\n    var fieldType = getBytes(2, i + 2);\n    var typeCount = getBytes(4, i + 4);\n    var valueOffset = getBytes(4, i + 8);\n    var fieldTagName = getFieldTagName(fieldTag);\n    var fieldTypeName = getFieldTypeName(fieldType);\n    var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n    tiffFields[fieldTagName] = {\n      type: fieldTypeName,\n      values: fieldValues\n    };\n  }\n  fileDirectories.push(tiffFields);\n  var nextIFDByteOffset = getBytes(4, i);\n  if (nextIFDByteOffset === 0x00000000) {\n    return fileDirectories;\n  } else {\n    return parseFileDirectory(nextIFDByteOffset);\n  }\n};\nexport var parseTIFF = function parseTIFF(tiffArrayBuffer, _canvas) {\n  var canvas = _canvas || document.createElement(\"canvas\");\n  if (!tiffArrayBuffer) return;\n  tiffDataView = new DataView(tiffArrayBuffer);\n  // canvas = _canvas;\n  littleEndian = isLittleEndian(tiffDataView);\n  if (!hasTowel(tiffDataView, littleEndian)) return;\n  var firstIFDByteOffset = getBytes(4, 4);\n  fileDirectories = parseFileDirectory(firstIFDByteOffset);\n  var fileDirectory = fileDirectories[0];\n  var imageWidth = fileDirectory.ImageWidth.values[0];\n  var imageLength = fileDirectory.ImageLength.values[0];\n  canvas.width = imageWidth;\n  canvas.height = imageLength;\n  var strips = [];\n  var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;\n  var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n  var sampleProperties = [];\n  var bitsPerPixel = 0;\n  var hasBytesPerPixel = false;\n  fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n    sampleProperties[i] = {\n      bitsPerSample: bitsPerSample,\n      hasBytesPerSample: false,\n      bytesPerSample: undefined\n    };\n    if (bitsPerSample % 8 === 0) {\n      sampleProperties[i].hasBytesPerSample = true;\n      sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n    }\n    bitsPerPixel += bitsPerSample;\n  }, _this);\n  if (bitsPerPixel % 8 === 0) {\n    hasBytesPerPixel = true;\n    var bytesPerPixel = bitsPerPixel / 8;\n  }\n  var stripOffsetValues = fileDirectory.StripOffsets.values;\n  var numStripOffsetValues = stripOffsetValues.length;\n  // StripByteCounts is supposed to be required, but see if we can recover anyway.\n  if (fileDirectory.StripByteCounts) {\n    var stripByteCountValues = fileDirectory.StripByteCounts.values;\n  } else {\n    // Infer StripByteCounts, if possible.\n    if (numStripOffsetValues === 1) {\n      var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];\n    } else {\n      throw Error(\"Cannot recover from missing StripByteCounts\");\n    }\n  }\n  // Loop through strips and decompress as necessary.\n  for (var i = 0; i < numStripOffsetValues; i++) {\n    var stripOffset = stripOffsetValues[i];\n    strips[i] = [];\n    var stripByteCount = stripByteCountValues[i];\n    // Loop through pixels.\n    for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n      // Decompress strip.\n      switch (compression) {\n        // Uncompressed\n        case 1:\n          // Loop through samples (sub-pixels).\n          for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n            if (sampleProperties[m].hasBytesPerSample) {\n              // XXX: This is wrong!\n              var sampleOffset = sampleProperties[m].bytesPerSample * m;\n              pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n            } else {\n              var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n              pixel.push(sampleInfo.bits);\n              byteOffset = sampleInfo.byteOffset - stripOffset;\n              bitOffset = sampleInfo.bitOffset;\n              throw RangeError(\"Cannot handle sub-byte bits per sample\");\n            }\n          }\n          strips[i].push(pixel);\n          if (hasBytesPerPixel) {\n            jIncrement = bytesPerPixel;\n          } else {\n            jIncrement = 0;\n            throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n          }\n          break;\n        // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n        case 2:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 3 Fax\n        case 3:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 4 Fax\n        case 4:\n          // XXX: Use PDF.js code?\n          break;\n        // LZW\n        case 5:\n          // XXX: Use PDF.js code?\n          break;\n        // Old-style JPEG (TIFF 6.0)\n        case 6:\n          // XXX: Use PDF.js code?\n          break;\n        // New-style JPEG (TIFF Specification Supplement 2)\n        case 7:\n          // XXX: Use PDF.js code?\n          break;\n        // PackBits\n        case 32773:\n          // Are we ready for a new block?\n          if (getHeader) {\n            getHeader = false;\n            var blockLength = 1;\n            var iterations = 1;\n            // The header byte is signed.\n            var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n            if (header >= 0 && header <= 127) {\n              // Normal pixels.\n              blockLength = header + 1;\n            } else if (header >= -127 && header <= -1) {\n              // Collapsed pixels.\n              iterations = -header + 1;\n            } /*if (header === -128)*/else {\n              // Placeholder byte?\n              getHeader = true;\n            }\n          } else {\n            var currentByte = getBytes(1, stripOffset + byteOffset);\n            // Duplicate bytes, if necessary.\n            for (var m = 0; m < iterations; m++) {\n              if (sampleProperties[sample].hasBytesPerSample) {\n                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                currentSample = currentSample << 8 * numBytes | currentByte;\n                numBytes++;\n                // Is our sample complete?\n                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                  pixel.push(currentSample);\n                  currentSample = numBytes = 0;\n                  sample++;\n                }\n              } else {\n                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n              }\n              // Is our pixel complete?\n              if (sample === samplesPerPixel) {\n                strips[i].push(pixel);\n                pixel = [];\n                sample = 0;\n              }\n            }\n            blockLength--;\n            // Is our block complete?\n            if (blockLength === 0) {\n              getHeader = true;\n            }\n          }\n          jIncrement = 1;\n          break;\n        // Unknown compression algorithm\n        default:\n          // Do not attempt to parse the image data.\n          break;\n      }\n    }\n  }\n  if (canvas.getContext) {\n    var ctx = canvas.getContext(\"2d\");\n    // Set a default fill style.\n    ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);\n    // If RowsPerStrip is missing, the whole image is in one strip.\n    if (fileDirectory.RowsPerStrip) {\n      var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n    } else {\n      var rowsPerStrip = imageLength;\n    }\n    var numStrips = strips.length;\n    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n    var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;\n    var numRowsInStrip = rowsPerStrip;\n    var numRowsInPreviousStrip = 0;\n    var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n    var extraSamplesValues = [];\n    var numExtraSamples = 0;\n    if (fileDirectory.ExtraSamples) {\n      extraSamplesValues = fileDirectory.ExtraSamples.values;\n      numExtraSamples = extraSamplesValues.length;\n    }\n    if (fileDirectory.ColorMap) {\n      var colorMapValues = fileDirectory.ColorMap.values;\n      var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n    }\n    // Loop through the strips in the image.\n    for (var i = 0; i < numStrips; i++) {\n      // The last strip may be short.\n      if (i + 1 === numStrips) {\n        numRowsInStrip = rowsInLastStrip;\n      }\n      var numPixels = strips[i].length;\n      var yPadding = numRowsInPreviousStrip * i;\n      // Loop through the rows in the strip.\n      for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n        // Loop through the pixels in the row.\n        for (var x = 0; x < imageWidth; x++, j++) {\n          var pixelSamples = strips[i][j];\n          var red = 0;\n          var green = 0;\n          var blue = 0;\n          var opacity = 1.0;\n          if (numExtraSamples > 0) {\n            for (var k = 0; k < numExtraSamples; k++) {\n              if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                // Clamp opacity to the range [0,1].\n                opacity = pixelSamples[3 + k] / 256;\n                break;\n              }\n            }\n          }\n          switch (photometricInterpretation) {\n            // Bilevel or Grayscale\n            // WhiteIsZero\n            case 0:\n              if (sampleProperties[0].hasBytesPerSample) {\n                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n              }\n              // Invert samples.\n              pixelSamples.forEach(function (sample, index, samples) {\n                samples[index] = invertValue - sample;\n              });\n            // Bilevel or Grayscale\n            // BlackIsZero\n            case 1:\n              red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              break;\n            // RGB Full Color\n            case 2:\n              red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n              blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n              break;\n            // RGB Color Palette\n            case 3:\n              if (colorMapValues === undefined) {\n                throw Error(\"Palette image missing color map\");\n              }\n              var colorMapIndex = pixelSamples[0];\n              red = clampColorSample(colorMapValues[colorMapIndex], 16);\n              green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n              blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n              break;\n            // Transparency mask\n            case 4:\n              throw RangeError(\"Not Yet Implemented: Transparency mask\");\n              break;\n            // CMYK\n            case 5:\n              throw RangeError(\"Not Yet Implemented: CMYK\");\n              break;\n            // YCbCr\n            case 6:\n              throw RangeError(\"Not Yet Implemented: YCbCr\");\n              break;\n            // CIELab\n            case 8:\n              throw RangeError(\"Not Yet Implemented: CIELab\");\n              break;\n            // Unknown Photometric Interpretation\n            default:\n              throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n              break;\n          }\n          ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n          ctx.fillRect(x, yPadding + y, 1, 1);\n        }\n      }\n      numRowsInPreviousStrip = numRowsInStrip;\n    }\n  }\n  return canvas;\n};","map":{"version":3,"names":["_this","tiffDataView","undefined","littleEndian","fileDirectories","isLittleEndian","BOM","getBytes","TypeError","hasTowel","RangeError","getFieldTagName","fieldTag","fieldTagNames","fieldTagName","getFieldTypeName","fieldType","fieldTypeNames","fieldTypeName","getFieldTypeLength","fieldTypeLength","indexOf","getBits","numBits","byteOffset","bitOffset","extraBytes","Math","floor","newByteOffset","totalBits","shiftRight","shiftLeft","rawBits","getUint8","getUint16","getUint32","chunkInfo","bits","numBytes","offset","getFieldValues","typeCount","valueOffset","fieldValues","fieldValueSize","value","push","i","indexOffset","forEach","e","a","String","fromCharCode","clampColorSample","colorSample","bitsPerSample","multiplier","pow","makeRGBAFillValue","r","g","b","parseFileDirectory","numDirEntries","tiffFields","entryCount","type","values","nextIFDByteOffset","parseTIFF","tiffArrayBuffer","_canvas","canvas","document","createElement","DataView","firstIFDByteOffset","fileDirectory","imageWidth","ImageWidth","imageLength","ImageLength","width","height","strips","compression","Compression","samplesPerPixel","SamplesPerPixel","sampleProperties","bitsPerPixel","hasBytesPerPixel","BitsPerSample","bitsPerSampleValues","hasBytesPerSample","bytesPerSample","bytesPerPixel","stripOffsetValues","StripOffsets","numStripOffsetValues","length","StripByteCounts","stripByteCountValues","ceil","Error","stripOffset","stripByteCount","jIncrement","getHeader","pixel","sample","currentSample","m","sampleOffset","sampleInfo","blockLength","iterations","header","getInt8","currentByte","getContext","ctx","fillStyle","RowsPerStrip","rowsPerStrip","numStrips","imageLengthModRowsPerStrip","rowsInLastStrip","numRowsInStrip","numRowsInPreviousStrip","photometricInterpretation","PhotometricInterpretation","extraSamplesValues","numExtraSamples","ExtraSamples","ColorMap","colorMapValues","colorMapSampleSize","numPixels","yPadding","y","j","x","pixelSamples","red","green","blue","opacity","k","invertValue","index","samples","colorMapIndex","fillRect"],"sources":["C:/Users/hoang/OneDrive/Máy tính/noname/node_modules/@cyntler/react-doc-viewer/dist/esm/renderers/tiff/tiffToCanvas.js"],"sourcesContent":["var _this = this;\r\n/* eslint-disable */\r\n// @ts-nocheck\r\nvar tiffDataView = undefined;\r\nvar littleEndian = undefined;\r\nvar fileDirectories = [];\r\nvar isLittleEndian = function () {\r\n    // Get byte order mark.\r\n    var BOM = getBytes(2, 0);\r\n    // Find out the endianness.\r\n    if (BOM === 0x4949) {\r\n        littleEndian = true;\r\n    }\r\n    else if (BOM === 0x4d4d) {\r\n        littleEndian = false;\r\n    }\r\n    else {\r\n        throw TypeError(\"Invalid byte order value.\");\r\n    }\r\n    return littleEndian;\r\n};\r\nvar hasTowel = function () {\r\n    // Check for towel.\r\n    if (getBytes(2, 2) !== 42) {\r\n        throw RangeError(\"You forgot your towel!\");\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nvar getFieldTagName = function (fieldTag) {\r\n    // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\r\n    // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\r\n    var fieldTagNames = {\r\n        // TIFF Baseline\r\n        0x013b: \"Artist\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0109: \"CellLength\",\r\n        0x0108: \"CellWidth\",\r\n        0x0140: \"ColorMap\",\r\n        0x0103: \"Compression\",\r\n        0x8298: \"Copyright\",\r\n        0x0132: \"DateTime\",\r\n        0x0152: \"ExtraSamples\",\r\n        0x010a: \"FillOrder\",\r\n        0x0121: \"FreeByteCounts\",\r\n        0x0120: \"FreeOffsets\",\r\n        0x0123: \"GrayResponseCurve\",\r\n        0x0122: \"GrayResponseUnit\",\r\n        0x013c: \"HostComputer\",\r\n        0x010e: \"ImageDescription\",\r\n        0x0101: \"ImageLength\",\r\n        0x0100: \"ImageWidth\",\r\n        0x010f: \"Make\",\r\n        0x0119: \"MaxSampleValue\",\r\n        0x0118: \"MinSampleValue\",\r\n        0x0110: \"Model\",\r\n        0x00fe: \"NewSubfileType\",\r\n        0x0112: \"Orientation\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x011c: \"PlanarConfiguration\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x0131: \"Software\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x0111: \"StripOffsets\",\r\n        0x00ff: \"SubfileType\",\r\n        0x0107: \"Threshholding\",\r\n        0x011a: \"XResolution\",\r\n        0x011b: \"YResolution\",\r\n        // TIFF Extended\r\n        0x0146: \"BadFaxLines\",\r\n        0x0147: \"CleanFaxData\",\r\n        0x0157: \"ClipPath\",\r\n        0x0148: \"ConsecutiveBadFaxLines\",\r\n        0x01b1: \"Decode\",\r\n        0x01b2: \"DefaultImageColor\",\r\n        0x010d: \"DocumentName\",\r\n        0x0150: \"DotRange\",\r\n        0x0141: \"HalftoneHints\",\r\n        0x015a: \"Indexed\",\r\n        0x015b: \"JPEGTables\",\r\n        0x011d: \"PageName\",\r\n        0x0129: \"PageNumber\",\r\n        0x013d: \"Predictor\",\r\n        0x013f: \"PrimaryChromaticities\",\r\n        0x0214: \"ReferenceBlackWhite\",\r\n        0x0153: \"SampleFormat\",\r\n        0x022f: \"StripRowCounts\",\r\n        0x014a: \"SubIFDs\",\r\n        0x0124: \"T4Options\",\r\n        0x0125: \"T6Options\",\r\n        0x0145: \"TileByteCounts\",\r\n        0x0143: \"TileLength\",\r\n        0x0144: \"TileOffsets\",\r\n        0x0142: \"TileWidth\",\r\n        0x012d: \"TransferFunction\",\r\n        0x013e: \"WhitePoint\",\r\n        0x0158: \"XClipPathUnits\",\r\n        0x011e: \"XPosition\",\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0159: \"YClipPathUnits\",\r\n        0x011f: \"YPosition\",\r\n        // EXIF\r\n        0x9202: \"ApertureValue\",\r\n        0xa001: \"ColorSpace\",\r\n        0x9004: \"DateTimeDigitized\",\r\n        0x9003: \"DateTimeOriginal\",\r\n        0x8769: \"Exif IFD\",\r\n        0x9000: \"ExifVersion\",\r\n        0x829a: \"ExposureTime\",\r\n        0xa300: \"FileSource\",\r\n        0x9209: \"Flash\",\r\n        0xa000: \"FlashpixVersion\",\r\n        0x829d: \"FNumber\",\r\n        0xa420: \"ImageUniqueID\",\r\n        0x9208: \"LightSource\",\r\n        0x927c: \"MakerNote\",\r\n        0x9201: \"ShutterSpeedValue\",\r\n        0x9286: \"UserComment\",\r\n        // IPTC\r\n        0x83bb: \"IPTC\",\r\n        // ICC\r\n        0x8773: \"ICC Profile\",\r\n        // XMP\r\n        0x02bc: \"XMP\",\r\n        // GDAL\r\n        0xa480: \"GDAL_METADATA\",\r\n        0xa481: \"GDAL_NODATA\",\r\n        // Photoshop\r\n        0x8649: \"Photoshop\",\r\n    };\r\n    var fieldTagName;\r\n    if (fieldTag in fieldTagNames) {\r\n        fieldTagName = fieldTagNames[fieldTag];\r\n    }\r\n    else {\r\n        fieldTagName = \"Tag\" + fieldTag;\r\n    }\r\n    return fieldTagName;\r\n};\r\nvar getFieldTypeName = function (fieldType) {\r\n    var fieldTypeNames = {\r\n        0x0001: \"BYTE\",\r\n        0x0002: \"ASCII\",\r\n        0x0003: \"SHORT\",\r\n        0x0004: \"LONG\",\r\n        0x0005: \"RATIONAL\",\r\n        0x0006: \"SBYTE\",\r\n        0x0007: \"UNDEFINED\",\r\n        0x0008: \"SSHORT\",\r\n        0x0009: \"SLONG\",\r\n        0x000a: \"SRATIONAL\",\r\n        0x000b: \"FLOAT\",\r\n        0x000c: \"DOUBLE\",\r\n    };\r\n    var fieldTypeName;\r\n    if (fieldType in fieldTypeNames) {\r\n        fieldTypeName = fieldTypeNames[fieldType];\r\n    }\r\n    return fieldTypeName;\r\n};\r\nvar getFieldTypeLength = function (fieldTypeName) {\r\n    var fieldTypeLength;\r\n    if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\r\n        fieldTypeLength = 1;\r\n    }\r\n    else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\r\n        fieldTypeLength = 2;\r\n    }\r\n    else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\r\n        fieldTypeLength = 4;\r\n    }\r\n    else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\r\n        fieldTypeLength = 8;\r\n    }\r\n    return fieldTypeLength;\r\n};\r\nvar getBits = function (numBits, byteOffset, bitOffset) {\r\n    bitOffset = bitOffset || 0;\r\n    var extraBytes = Math.floor(bitOffset / 8);\r\n    var newByteOffset = byteOffset + extraBytes;\r\n    var totalBits = bitOffset + numBits;\r\n    var shiftRight = 32 - numBits;\r\n    if (totalBits <= 0) {\r\n        throw RangeError(\"No bits requested\");\r\n    }\r\n    else if (totalBits <= 8) {\r\n        var shiftLeft = 24 + bitOffset;\r\n        var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\r\n    }\r\n    else if (totalBits <= 16) {\r\n        var shiftLeft = 16 + bitOffset;\r\n        var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\r\n    }\r\n    else if (totalBits <= 32) {\r\n        var shiftLeft = bitOffset;\r\n        var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\r\n    }\r\n    else {\r\n        throw RangeError(\"Too many bits requested\");\r\n    }\r\n    var chunkInfo = {\r\n        bits: (rawBits << shiftLeft) >>> shiftRight,\r\n        byteOffset: newByteOffset + Math.floor(totalBits / 8),\r\n        bitOffset: totalBits % 8,\r\n    };\r\n    return chunkInfo;\r\n};\r\nvar getBytes = function (numBytes, offset) {\r\n    if (numBytes <= 0) {\r\n        throw RangeError(\"No bytes requested\");\r\n    }\r\n    else if (numBytes <= 1) {\r\n        return tiffDataView.getUint8(offset, littleEndian);\r\n    }\r\n    else if (numBytes <= 2) {\r\n        return tiffDataView.getUint16(offset, littleEndian);\r\n    }\r\n    else if (numBytes <= 3) {\r\n        return tiffDataView.getUint32(offset, littleEndian) >>> 8;\r\n    }\r\n    else if (numBytes <= 4) {\r\n        return tiffDataView.getUint32(offset, littleEndian);\r\n    }\r\n    else {\r\n        throw RangeError(\"Too many bytes requested\");\r\n    }\r\n};\r\nvar getFieldValues = function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\r\n    var fieldValues = [];\r\n    var fieldTypeLength = getFieldTypeLength(fieldTypeName);\r\n    var fieldValueSize = fieldTypeLength * typeCount;\r\n    if (fieldValueSize <= 4) {\r\n        // The value is stored at the big end of the valueOffset.\r\n        if (littleEndian === false) {\r\n            var value = valueOffset >>> ((4 - fieldTypeLength) * 8);\r\n        }\r\n        else {\r\n            var value = valueOffset;\r\n        }\r\n        fieldValues.push(value);\r\n    }\r\n    else {\r\n        for (var i = 0; i < typeCount; i++) {\r\n            var indexOffset = fieldTypeLength * i;\r\n            if (fieldTypeLength >= 8) {\r\n                if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\r\n                    // Numerator\r\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset));\r\n                    // Denominator\r\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));\r\n                    //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\r\n                    //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\r\n                }\r\n                else {\r\n                    throw TypeError(\"Can't handle this field type or size\");\r\n                }\r\n            }\r\n            else {\r\n                fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\r\n            }\r\n        }\r\n    }\r\n    if (fieldTypeName === \"ASCII\") {\r\n        fieldValues.forEach(function (e, i, a) {\r\n            a[i] = String.fromCharCode(e);\r\n        });\r\n    }\r\n    return fieldValues;\r\n};\r\nvar clampColorSample = function (colorSample, bitsPerSample) {\r\n    var multiplier = Math.pow(2, 8 - bitsPerSample);\r\n    return Math.floor(colorSample * multiplier + (multiplier - 1));\r\n};\r\nvar makeRGBAFillValue = function (r, g, b, a) {\r\n    if (typeof a === \"undefined\") {\r\n        a = 1.0;\r\n    }\r\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\r\n};\r\nvar parseFileDirectory = function (byteOffset) {\r\n    var numDirEntries = getBytes(2, byteOffset);\r\n    var tiffFields = [];\r\n    for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\r\n        var fieldTag = getBytes(2, i);\r\n        var fieldType = getBytes(2, i + 2);\r\n        var typeCount = getBytes(4, i + 4);\r\n        var valueOffset = getBytes(4, i + 8);\r\n        var fieldTagName = getFieldTagName(fieldTag);\r\n        var fieldTypeName = getFieldTypeName(fieldType);\r\n        var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\r\n        tiffFields[fieldTagName] = { type: fieldTypeName, values: fieldValues };\r\n    }\r\n    fileDirectories.push(tiffFields);\r\n    var nextIFDByteOffset = getBytes(4, i);\r\n    if (nextIFDByteOffset === 0x00000000) {\r\n        return fileDirectories;\r\n    }\r\n    else {\r\n        return parseFileDirectory(nextIFDByteOffset);\r\n    }\r\n};\r\nexport var parseTIFF = function (tiffArrayBuffer, _canvas) {\r\n    var canvas = _canvas || document.createElement(\"canvas\");\r\n    if (!tiffArrayBuffer)\r\n        return;\r\n    tiffDataView = new DataView(tiffArrayBuffer);\r\n    // canvas = _canvas;\r\n    littleEndian = isLittleEndian(tiffDataView);\r\n    if (!hasTowel(tiffDataView, littleEndian))\r\n        return;\r\n    var firstIFDByteOffset = getBytes(4, 4);\r\n    fileDirectories = parseFileDirectory(firstIFDByteOffset);\r\n    var fileDirectory = fileDirectories[0];\r\n    var imageWidth = fileDirectory.ImageWidth.values[0];\r\n    var imageLength = fileDirectory.ImageLength.values[0];\r\n    canvas.width = imageWidth;\r\n    canvas.height = imageLength;\r\n    var strips = [];\r\n    var compression = fileDirectory.Compression\r\n        ? fileDirectory.Compression.values[0]\r\n        : 1;\r\n    var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\r\n    var sampleProperties = [];\r\n    var bitsPerPixel = 0;\r\n    var hasBytesPerPixel = false;\r\n    fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\r\n        sampleProperties[i] = {\r\n            bitsPerSample: bitsPerSample,\r\n            hasBytesPerSample: false,\r\n            bytesPerSample: undefined,\r\n        };\r\n        if (bitsPerSample % 8 === 0) {\r\n            sampleProperties[i].hasBytesPerSample = true;\r\n            sampleProperties[i].bytesPerSample = bitsPerSample / 8;\r\n        }\r\n        bitsPerPixel += bitsPerSample;\r\n    }, _this);\r\n    if (bitsPerPixel % 8 === 0) {\r\n        hasBytesPerPixel = true;\r\n        var bytesPerPixel = bitsPerPixel / 8;\r\n    }\r\n    var stripOffsetValues = fileDirectory.StripOffsets.values;\r\n    var numStripOffsetValues = stripOffsetValues.length;\r\n    // StripByteCounts is supposed to be required, but see if we can recover anyway.\r\n    if (fileDirectory.StripByteCounts) {\r\n        var stripByteCountValues = fileDirectory.StripByteCounts.values;\r\n    }\r\n    else {\r\n        // Infer StripByteCounts, if possible.\r\n        if (numStripOffsetValues === 1) {\r\n            var stripByteCountValues = [\r\n                Math.ceil((imageWidth * imageLength * bitsPerPixel) / 8),\r\n            ];\r\n        }\r\n        else {\r\n            throw Error(\"Cannot recover from missing StripByteCounts\");\r\n        }\r\n    }\r\n    // Loop through strips and decompress as necessary.\r\n    for (var i = 0; i < numStripOffsetValues; i++) {\r\n        var stripOffset = stripOffsetValues[i];\r\n        strips[i] = [];\r\n        var stripByteCount = stripByteCountValues[i];\r\n        // Loop through pixels.\r\n        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n            // Decompress strip.\r\n            switch (compression) {\r\n                // Uncompressed\r\n                case 1:\r\n                    // Loop through samples (sub-pixels).\r\n                    for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\r\n                        if (sampleProperties[m].hasBytesPerSample) {\r\n                            // XXX: This is wrong!\r\n                            var sampleOffset = sampleProperties[m].bytesPerSample * m;\r\n                            pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\r\n                        }\r\n                        else {\r\n                            var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\r\n                            pixel.push(sampleInfo.bits);\r\n                            byteOffset = sampleInfo.byteOffset - stripOffset;\r\n                            bitOffset = sampleInfo.bitOffset;\r\n                            throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                        }\r\n                    }\r\n                    strips[i].push(pixel);\r\n                    if (hasBytesPerPixel) {\r\n                        jIncrement = bytesPerPixel;\r\n                    }\r\n                    else {\r\n                        jIncrement = 0;\r\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\r\n                    }\r\n                    break;\r\n                // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\r\n                case 2:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // Group 3 Fax\r\n                case 3:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // Group 4 Fax\r\n                case 4:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // LZW\r\n                case 5:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // Old-style JPEG (TIFF 6.0)\r\n                case 6:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // New-style JPEG (TIFF Specification Supplement 2)\r\n                case 7:\r\n                    // XXX: Use PDF.js code?\r\n                    break;\r\n                // PackBits\r\n                case 32773:\r\n                    // Are we ready for a new block?\r\n                    if (getHeader) {\r\n                        getHeader = false;\r\n                        var blockLength = 1;\r\n                        var iterations = 1;\r\n                        // The header byte is signed.\r\n                        var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\r\n                        if (header >= 0 && header <= 127) {\r\n                            // Normal pixels.\r\n                            blockLength = header + 1;\r\n                        }\r\n                        else if (header >= -127 && header <= -1) {\r\n                            // Collapsed pixels.\r\n                            iterations = -header + 1;\r\n                        } /*if (header === -128)*/\r\n                        else {\r\n                            // Placeholder byte?\r\n                            getHeader = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var currentByte = getBytes(1, stripOffset + byteOffset);\r\n                        // Duplicate bytes, if necessary.\r\n                        for (var m = 0; m < iterations; m++) {\r\n                            if (sampleProperties[sample].hasBytesPerSample) {\r\n                                // We're reading one byte at a time, so we need to handle multi-byte samples.\r\n                                currentSample = (currentSample << (8 * numBytes)) | currentByte;\r\n                                numBytes++;\r\n                                // Is our sample complete?\r\n                                if (numBytes === sampleProperties[sample].bytesPerSample) {\r\n                                    pixel.push(currentSample);\r\n                                    currentSample = numBytes = 0;\r\n                                    sample++;\r\n                                }\r\n                            }\r\n                            else {\r\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                            }\r\n                            // Is our pixel complete?\r\n                            if (sample === samplesPerPixel) {\r\n                                strips[i].push(pixel);\r\n                                pixel = [];\r\n                                sample = 0;\r\n                            }\r\n                        }\r\n                        blockLength--;\r\n                        // Is our block complete?\r\n                        if (blockLength === 0) {\r\n                            getHeader = true;\r\n                        }\r\n                    }\r\n                    jIncrement = 1;\r\n                    break;\r\n                // Unknown compression algorithm\r\n                default:\r\n                    // Do not attempt to parse the image data.\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    if (canvas.getContext) {\r\n        var ctx = canvas.getContext(\"2d\");\r\n        // Set a default fill style.\r\n        ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);\r\n        // If RowsPerStrip is missing, the whole image is in one strip.\r\n        if (fileDirectory.RowsPerStrip) {\r\n            var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\r\n        }\r\n        else {\r\n            var rowsPerStrip = imageLength;\r\n        }\r\n        var numStrips = strips.length;\r\n        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\r\n        var rowsInLastStrip = imageLengthModRowsPerStrip === 0\r\n            ? rowsPerStrip\r\n            : imageLengthModRowsPerStrip;\r\n        var numRowsInStrip = rowsPerStrip;\r\n        var numRowsInPreviousStrip = 0;\r\n        var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\r\n        var extraSamplesValues = [];\r\n        var numExtraSamples = 0;\r\n        if (fileDirectory.ExtraSamples) {\r\n            extraSamplesValues = fileDirectory.ExtraSamples.values;\r\n            numExtraSamples = extraSamplesValues.length;\r\n        }\r\n        if (fileDirectory.ColorMap) {\r\n            var colorMapValues = fileDirectory.ColorMap.values;\r\n            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\r\n        }\r\n        // Loop through the strips in the image.\r\n        for (var i = 0; i < numStrips; i++) {\r\n            // The last strip may be short.\r\n            if (i + 1 === numStrips) {\r\n                numRowsInStrip = rowsInLastStrip;\r\n            }\r\n            var numPixels = strips[i].length;\r\n            var yPadding = numRowsInPreviousStrip * i;\r\n            // Loop through the rows in the strip.\r\n            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\r\n                // Loop through the pixels in the row.\r\n                for (var x = 0; x < imageWidth; x++, j++) {\r\n                    var pixelSamples = strips[i][j];\r\n                    var red = 0;\r\n                    var green = 0;\r\n                    var blue = 0;\r\n                    var opacity = 1.0;\r\n                    if (numExtraSamples > 0) {\r\n                        for (var k = 0; k < numExtraSamples; k++) {\r\n                            if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\r\n                                // Clamp opacity to the range [0,1].\r\n                                opacity = pixelSamples[3 + k] / 256;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    switch (photometricInterpretation) {\r\n                        // Bilevel or Grayscale\r\n                        // WhiteIsZero\r\n                        case 0:\r\n                            if (sampleProperties[0].hasBytesPerSample) {\r\n                                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\r\n                            }\r\n                            // Invert samples.\r\n                            pixelSamples.forEach(function (sample, index, samples) {\r\n                                samples[index] = invertValue - sample;\r\n                            });\r\n                        // Bilevel or Grayscale\r\n                        // BlackIsZero\r\n                        case 1:\r\n                            red =\r\n                                green =\r\n                                    blue =\r\n                                        clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\r\n                            break;\r\n                        // RGB Full Color\r\n                        case 2:\r\n                            red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\r\n                            green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\r\n                            blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\r\n                            break;\r\n                        // RGB Color Palette\r\n                        case 3:\r\n                            if (colorMapValues === undefined) {\r\n                                throw Error(\"Palette image missing color map\");\r\n                            }\r\n                            var colorMapIndex = pixelSamples[0];\r\n                            red = clampColorSample(colorMapValues[colorMapIndex], 16);\r\n                            green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\r\n                            blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\r\n                            break;\r\n                        // Transparency mask\r\n                        case 4:\r\n                            throw RangeError(\"Not Yet Implemented: Transparency mask\");\r\n                            break;\r\n                        // CMYK\r\n                        case 5:\r\n                            throw RangeError(\"Not Yet Implemented: CMYK\");\r\n                            break;\r\n                        // YCbCr\r\n                        case 6:\r\n                            throw RangeError(\"Not Yet Implemented: YCbCr\");\r\n                            break;\r\n                        // CIELab\r\n                        case 8:\r\n                            throw RangeError(\"Not Yet Implemented: CIELab\");\r\n                            break;\r\n                        // Unknown Photometric Interpretation\r\n                        default:\r\n                            throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\r\n                            break;\r\n                    }\r\n                    ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\r\n                    ctx.fillRect(x, yPadding + y, 1, 1);\r\n                }\r\n            }\r\n            numRowsInPreviousStrip = numRowsInStrip;\r\n        }\r\n    }\r\n    return canvas;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}